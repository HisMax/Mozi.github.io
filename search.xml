<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【杂记】2020年3月28日</title>
    <url>/2020/03/14f0aad4/</url>
    <content><![CDATA[<p><img
src="https://images.cnblogs.com/cnblogs_com/Histone/1682817/o_200328051122original(1).jpg" /></p>
<p><strong>打开电脑→打开OJ→浏览题目→浏览博客→“颓”→关闭电脑</strong></p>
<p>按理说，过了凌晨，2020-03-28就已经来到了。</p>
<p>CCF的通知上说的，今天就是省选的Day1</p>
<p>疫情的来临使得咕咕F更咕了些，至今未通知何时省选。</p>
<p><del>（发邮件给特派员也不回，23333）</del></p>
<p>现在每天都感觉自己非常蒟蒻</p>
<p>今天看了一部电影《贫民窟里的百万富翁》</p>
<p>给我感触最深的是，这个电影并没有讲金钱意义上的百万富翁。</p>
<p>而是讲述了主人公从小到大的经历，正是这种经历才使得主人公成为了百万富翁。</p>
<p>或许我希望是这样吧。</p>
<p>停课去搞OI，真的需要很大的勇气与毅力。</p>
<p>老师不理解，学校不理解，同学不理解。他们很难想象我居然为了一个看不见摸不着的OI放弃两个月的文化课。</p>
<p>但我真的是非常喜欢OI，从小学六年级接触到易语言时，我就感受到了编程的魅力。</p>
<p>从那之后，自学了Java，Python，C++……，可惜高中前学的都是语言</p>
<p>直到高一，我才真正意义上接触到OI，仗着年轻气盛，憨批的我参加了2018NOIP</p>
<p>那肯定爆零了啊，直接提高，我还是全市唯一一个C语言的……23333</p>
<p>然后呢，我在文化课里颓了一年，由普通班升到了重点班（可惜不是最重点）</p>
<p>直到2019年9月13日，我才惊醒到，原来我还有OI。</p>
<p>于是拼命肝了两个月，2019CSP-TG 捞了一个弱省二等</p>
<p>之后，我发现我彻底爱上了OI，解题的快乐，AC的那一瞬间</p>
<p>假期去清北学堂集训了一次
<del>（最心疼的是钱，对于贫困家庭来说，支出不小）</del></p>
<p>也没认识许多大佬，大部分水平还是差不多了，其实是真正的大佬不屑和我这个蒟蒻交朋友</p>
<p>由于在弱省，省选竞争不是很大，二等也可以混进去考一下。</p>
<p>但是……我想进队</p>
<p>于是就开启了停课，疯狂刷题阶段。</p>
<p>进了队，我就继续停课，至少要打个Ag回来</p>
<p>没进队，就滚回去学文化课，2020再考最后一次NOIP，正式AFO~</p>
<p>怎么说呢，文笔很烂，感觉跟流水账似的。</p>
<p><strong>PS：话说2020省选啥时候通知啊，我TM直接自闭好不好，就算推迟，给个通知啊！！！</strong></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>日常</tag>
        <tag>省选</tag>
        <tag>颓废</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】TexLive超详细安装指南（Windows）</title>
    <url>/2023/05/ef1f5b3c/</url>
    <content><![CDATA[<blockquote>
<p>本文将详细介绍如何安装TexLive，使用TexLive编译LaTeX文档。让你在Windows上也能愉快的使用LaTeX，体验到LaTeX的魅力。</p>
</blockquote>
<p>想必大家都或多或少知道LaTeX究竟是个什么东西</p>
<h2 id="什么是texlive">什么是TexLive</h2>
<p><strong>TexLive是一个免费、开源的TeX发行版，它包含了用于排版各种类型文档的TeX系统和许多相关工具、字体、宏包和文档。</strong>
TeX是一种专业的排版系统，用于创建高质量的科技论文、书籍、期刊和其他技术文档，它在学术界和出版业广泛使用。</p>
<p>TexLive包含了许多与TeX相关的软件包和工具，<strong>包括LaTeX、ConTeXt、MetaPost、pdfTeX、LuaTeX等等。</strong>
它是一个跨平台的软件，可以在不同的操作系统上使用，例如Windows、Linux、MacOS等。</p>
<p><strong>简而言之：当你需要写一份专业的科技论文、书籍、期刊或其他技术文档时，排版是非常重要的一步。TeX是一种专业的排版系统，可以让你创建高质量的文档，它在学术界和出版业广泛使用。</strong></p>
<h2 id="为什么要使用texlive">为什么要使用TexLive</h2>
<p>其实，TexLive并不是唯一的TeX发行版，还有许多其他的发行版，例如MiKTeX、MacTeX等等。那么，为什么要使用TexLive呢？</p>
<p>TexLive是一个跨平台的软件，可以在不同的操作系统上使用，例如Windows、Linux、MacOS等。而其他的TeX发行版，例如MiKTeX、MacTeX等，只能在特定的操作系统上使用，例如MiKTeX只能在Windows上使用，MacTeX只能在MacOS上使用。</p>
<h2 id="国内texlive下载">国内TexLive下载</h2>
<p>首选清华大学开源软件镜像站：<a
href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">点我下载</a>、</p>
<p>打开后选择最新的版本，例如这个2023年0313版本：</p>
<p><img src="https://s2.loli.net/2023/05/05/VGIQ6b95wWHn4Xk.png" /></p>
<p>这个<code>TexLive</code>有四五个G，看来下载要等一会儿了。</p>
<p>如果对下载速度有要求的同学可以尝试一下
<code>IDM</code>、<code>FDM</code> 等多线程加速的下载器。</p>
<p>不过几分钟，我们的下载就完成啦~</p>
<p>接下来的任务是安装</p>
<hr />
<h2 id="安装texlivewindows">安装TexLive（Windows）</h2>
<p>双击我们刚刚下载好的文件</p>
<p><img src="https://s2.loli.net/2023/05/05/Y7k3fOxsC9LFHqG.png" /></p>
<p>会弹出一个选择应用打开的窗口</p>
<p><img src="https://s2.loli.net/2023/05/05/vs9FckBGqRPYz7x.png" /></p>
<p>我们选择资源管理器即可</p>
<p>这时候，<code>我的计算机</code> 里会多出来一个软驱（DVD驱动器）</p>
<p><img src="https://s2.loli.net/2023/05/05/QafUJpcZCFVNT5b.png" /></p>
<p>我们打开后看到的就是TexLive的全部文件</p>
<p>这里选择打开 <code>install-tl-windows.bat</code></p>
<p><img src="https://s2.loli.net/2023/05/05/dAD6IwP7bipVEMg.png" /></p>
<p>打开后，稍等一会儿，我们就可以看到我们的安装窗口</p>
<p><img src="https://s2.loli.net/2023/05/05/9iSW5oRPuQL6fgk.png" /></p>
<p>安装窗口大概长这样</p>
<p>如果不是中文界面的小伙伴可以选择菜单里的 <code>GUI Languaga</code>
来修改界面的语言</p>
<p><img src="https://s2.loli.net/2023/05/05/lA58RHTx3rs1pbi.png" /></p>
<p>这里默子肯定是选到中文滴</p>
<p>然后我们修改一下安装的硬盘分区（可选）</p>
<p>点击界面上路径后面的 <code>修改</code> 按钮</p>
<p>会弹出一个选择路径的界面</p>
<p><img src="https://s2.loli.net/2023/05/05/fbcxk2l7rWZOend.png" /></p>
<p>这里默子就选择改装到H盘去了，毕竟如果都装C盘的话，C盘迟早变
<code>血红战神</code></p>
<blockquote>
<p>默子暴论：如果可以自定义路径的软件还装C盘，那就是xx</p>
</blockquote>
<p>一切都确定后，就可以点击安装啦！</p>
<p><strong>注意，这个安装可能会耗时1个小时。所以确保1个小时内，电脑都可以持续正常工作，不要装一半了突然笔记本没电关机，那就尴尬了。</strong></p>
<p><img src="https://s2.loli.net/2023/05/05/iB1KbkLNAIE7a9F.png" /></p>
<p>安装界面这里经常会出现一些问题，比如可能有的同学会闪退，我们后面再讨论这里报错的问题。</p>
<p>等到这个4490出现（反正是差不多的数字就行），说明我们的安装开始进行了。</p>
<p>后面有剩余时间的估计，不过这个时间经常是不准的，一般安装时间都要持续<code>40min</code></p>
<p><strong>默子是13900HX的CPU，开了性能模式，安装了大概51min吧</strong></p>
<p>安装好后的提示如图</p>
<p><img src="https://s2.loli.net/2023/05/05/HOBuf9wEGNM4Q8R.png" /></p>
<p>自此，我们的TexLive就已经成功安装完毕</p>
<p>后续默子再来讲一讲，如何在VSCode里配置我们最舒适的LaTeX编码环境</p>
<p>让我们的生产效率 UP UP ~</p>
<p><a href="/">【施工中】TexLive与VSCode能碰撞出怎样的火花</a></p>
<p><a href="/">【施工中】让人工智能辅助我们创作优秀的排版作品</a></p>
<p><a href="/">【施工中】最舒适的TeX编写指南</a></p>
<h2 id="参考资料">参考资料</h2>
<p>中文LaTeX社区：<a
href="https://www.latexstudio.net/">LaTeX工作室</a></p>
<p>更多关于TeX的知识，可以参考这篇文章：<a
href="https://www.latexstudio.net/texdoc/#/28?page_id=133">TeX
家族与基础概念</a></p>
<p>更多关于其他发行版的知识，可以参考这篇文章：<a
href="https://www.latexstudio.net/texdoc/#/28?page_id=114">LaTeX
发行版与下载</a></p>
]]></content>
      <categories>
        <category>软件教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>LaTeX</tag>
        <tag>TexLive</tag>
      </tags>
  </entry>
  <entry>
    <title>【杂记】2020年3月8日</title>
    <url>/2020/03/e8c50af6/</url>
    <content><![CDATA[<h3 id="早上-930">早上 9：30</h3>
<p>迷迷糊糊地吃了一碗方便面，又打开了电脑。</p>
<p><strong>熟悉的洛谷，熟悉的DevCpp</strong></p>
<p>第一件事是，用民间数据把昨天NOI Online的代码测试了下</p>
<p>25+0+0</p>
<p>哇，心态瞬间<strong>爆炸</strong>……</p>
<p><del>（第一题明明有50的啊，第二题怎么又爆0了，第三题意料之中）</del></p>
<p>还是要调整好自己的心态，毕竟自己是真的蒟蒻,</p>
<p>短时间菜一点可以容忍，但绝不能容忍长时间的菜！！！</p>
<hr />
<h3 id="上午-1030">上午 10：30</h3>
<p>今天距离<strong>省选</strong>还有——<strong>21</strong>天啊</p>
<p>调整好心态继续加油。。。</p>
<p>学着学着，突然发现，树状数组给我整蒙圈了</p>
<p>以前就是<strong>会打板子</strong>，今天花了我好长时间总于搞懂<strong>其中的原理的lowbit操作</strong>是个什么鬼了！</p>
<p>众所周知，树状数组可以维护区间和</p>
<p>比如给我们一个 <strong>num[ ]</strong> 数组，长度为
<strong>n</strong>。</p>
<p>并且我们打算把它加到我们的树状数组 <strong>tree[ ]</strong> 中去</p>
<p><strong>如下图</strong></p>
<p><a href="https://imgchr.com/i/3zyxPA"><img
src="https://s2.ax1x.com/2020/03/08/3zyxPA.png"
alt="3zyxPA.png" /></a></p>
<h4 id="树状数组修改插入操作">树状数组修改插入操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> a)</span></span>&#123;<br>    <span class="hljs-comment">//x是插入的位置</span><br>    <span class="hljs-comment">//a是要插入的值</span><br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        tree[x]+=a;<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>        <span class="hljs-comment">//也就是 x = x&amp;-x</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>假设 x = 1,n = 8,a = 5,则</strong></p>
<p><strong>tree[1]+=5</strong> <strong>tree[2]+=5</strong>
<strong>tree[4]+=5</strong> <strong>tree[8]+=5</strong></p>
<p>lowbit()返回的其实就是x在二进制下，末尾
<strong>第一个遇到的1和在那之前的0</strong> 的情况，比如：</p>
<p><strong>0001 1</strong> lowbit(1) = 1</p>
<p><strong>0010 2</strong> lowbit(2) = 2</p>
<p><strong>0011 3</strong> lowbit(3) = 1</p>
<p><strong>0100 4</strong> lowbit(4) = 4</p>
<p><strong>0101 5</strong> lowbit(5) = 1</p>
<p><strong>0110 6</strong> lowbit(6) = 2</p>
<p><strong>0111 7</strong> lowbit(7) = 1</p>
<p><strong>1000 8</strong> lowbit(8) = 8</p>
<p>给一个随便给一个数字 <strong>5201314‬</strong>
<del>(不用怀疑准确性，我用计算器算的)</del></p>
<p><strong>lowbit(5201314) = 2</strong></p>
<p>因为 <strong>5201314</strong>的二进制模样长这样：<strong>100 1111
0101 1101 1010 0010‬</strong></p>
<p>关心最后两位 100 1111 0101 1101 1010 00<strong>10‬</strong></p>
<p>就是二进制的 <strong>2</strong></p>
<p>至于具体的运算参考手边二进制运算课本，<del>没有？那百度啊</del></p>
<h4 id="树状数组区间求和从x到1操作">树状数组区间求和(从x到1)操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//x还是位置</span><br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(x)&#123;<br>		ans += treen[x];<br>		x -= <span class="hljs-built_in">lowbit</span>(x);<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>什么，你要求和5到12区间内的和？？？</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">ans = <span class="hljs-built_in">sum</span>(<span class="hljs-number">12</span>) - <span class="hljs-built_in">sum</span>(<span class="hljs-number">5</span><span class="hljs-number">-1</span>);<br><br></code></pre></td></tr></table></figure>
<p><del>很颓很颓的一上午，虽然我知道我可能上面没太讲清</del></p>
<p><del>但是那又有什么关系呢，这只是一篇类似于 <strong>日记</strong>
的东东</del></p>
<hr />
<h3 id="中午-1320">中午 13：20</h3>
<p>吃了一大盘鸡肉+两碗米饭 <del>(具体菜名叫不上来)</del></p>
<p>来了客人，家里把以前的旧车卖了，来的是买车的人</p>
<p>说实话，他们都认识我，我不认识他们，233333</p>
<p>关上卧室门，逍遥自在</p>
<hr />
<h3 id="下午-1400">下午 14：00</h3>
<p>刚准备打开游戏，看看沙雕可爱的 <strong>羽羽音小鸟(はばね
ことり)</strong></p>
<p>以及开朗温柔的 <strong>姫城扬羽(ひめぎ あげは)</strong></p>
<p>突然想起来有洛谷月赛啊……淦！</p>
<p>(因为我太弱，所以只做了Div2)</p>
<p><strong>T1</strong>
第一眼还以为是八皇后问题，但仔细一看……什么嘛，入门组水题</p>
<p>20分钟愉快切掉 <del>(中间边界条件搞错WA了两次)</del></p>
<p><strong>T2</strong>
明显是道数学结论题，一开始写了个O(K)的算法上去</p>
<p>果不其然，TLE掉最后一组数据</p>
<p>思考了好久，推了下式子</p>
<p><span class="math inline">\(\text{(n+1) * pow(2,k)}\)</span></p>
<p>鉴于k比较大，写个快速幂水过去了</p>
<p><strong>T3</strong> 卡了 我两个小时</p>
<p>各种瞎搞算法都用过，好像是DP，但是也用前缀和搞过</p>
<p>最后DFS暴力14分，果断滚粗</p>
<p><strong>T4</strong> 没看……</p>
<hr />
<h3 id="傍晚-1900">傍晚 19：00</h3>
<p>打开了Steam，心不在焉地玩着<strong>If My Heart Had Wings</strong></p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/ivxjt9tg.png" /></p>
<p>无聊中解答了几个问题，推进了下剧情</p>
<p>记忆化搜索？(×)</p>
<p>瞎搞 (√)</p>
<hr />
<h3 id="晚上-2200">晚上 22：00</h3>
<p>关掉了游戏，写下博客</p>
<p>决定当个日更博客主</p>
<hr />
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>日常</tag>
        <tag>树状数组</tag>
        <tag>NOI省选</tag>
      </tags>
  </entry>
  <entry>
    <title>【洛谷题解】P1104 生日</title>
    <url>/2019/09/2b2e6ad9/</url>
    <content><![CDATA[<p><del>蒟蒻第一次发题解</del> 望大佬们海涵</p>
<p>看到这题的瞬间，我想到了一个鬼点子。</p>
<p>（翻了翻看到有类似题解，不过稍稍还是有点出入）</p>
<p>倘若把每个人的出生日期看做他的死亡日期。
把出生日期设为公元第一年一月一日的话……</p>
<p>那就计算他从公元 1.1.1 — xxxx.x.xx
一共有多少天就好了，<del>然后排序输出</del></p>
<p><del>（每个人都是千年老妖，有点恐怖）</del></p>
<p>从公元到死亡的日子 = 年×365+月×30+日;</p>
<p>排序什么的随便啦（<del>本蒟蒻冒泡</del>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sr</span>&#123;<br>	string name;<br>	<span class="hljs-type">int</span> n,y,r;<br>&#125;xs[<span class="hljs-number">120</span>];<span class="hljs-comment">//结构体，nian年，yue月，ri日。一目了然的变量名，哈哈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>	<span class="hljs-type">int</span> k,i,j,temp1,temp2;<br>	cin&gt;&gt;k;<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;k;i++)cin&gt;&gt;xs[i].name&gt;&gt;xs[i].n&gt;&gt;xs[i].y&gt;&gt;xs[i].r;<span class="hljs-comment">//输入每个人的信息</span><br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j&lt;k;j++)&#123;<br>			temp1 = xs[i].n*<span class="hljs-number">365</span>+xs[i].y*<span class="hljs-number">30</span>+xs[i].r;<br>			temp2 = xs[j].n*<span class="hljs-number">365</span>+xs[j].y*<span class="hljs-number">30</span>+xs[j].r;<br>			<span class="hljs-keyword">if</span>(temp1&lt;=temp2)<span class="hljs-built_in">swap</span>(xs[i],xs[j]);		<br>		&#125;<span class="hljs-comment">//蒟蒻的冒泡排序</span><br>	&#125;<br>	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;k;i++)cout&lt;&lt;xs[i].name&lt;&lt;endl;<span class="hljs-comment">//输出就好了</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】普通平衡树</title>
    <url>/2020/03/6734e3c6/</url>
    <content><![CDATA[<h2 id="来自刚刚学会treap的蒟蒻">来自刚刚学会Treap的蒟蒻</h2>
<p>题目链接： - <a href="https://www.luogu.com.cn/problem/P6136">P6136
【模板】普通平衡树（数据加强版）</a> - 弱化版 <a
href="https://www.luogu.com.cn/problem/P3369">P6136
【模板】普通平衡树</a></p>
<p>特别不习惯用一堆数组，结构体多香啊</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> son[<span class="hljs-number">2</span>];<span class="hljs-comment">//son[</span><br>    <span class="hljs-type">int</span> size,cnt;<br>    <span class="hljs-type">int</span> val,rd;<br>&#125;trp[<span class="hljs-number">1500000</span>];<br><span class="hljs-type">int</span> tot,root;<br></code></pre></td></tr></table></figure>
<p>其实完整代码里都有~ 只不过无聊，单独拿出来~ <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rrand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> seed=(<span class="hljs-type">int</span>)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(seed)*<span class="hljs-number">974485642LL</span>%<span class="hljs-number">21474836LL</span>);<br>    <span class="hljs-comment">/*手写rand()取随机数*/</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> re register</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rd(x) x=read()</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> son[<span class="hljs-number">2</span>];<span class="hljs-comment">//son[0]左儿子，son[1]右儿子</span><br>    <span class="hljs-type">int</span> size,cnt;<br>    <span class="hljs-comment">//因为treap不希望出现值相同的节点，（想想为什么）</span><br>    <span class="hljs-comment">//所以用cnt统计相同的值</span><br>    <span class="hljs-type">int</span> val,rd;<br>    <span class="hljs-comment">//rd 是随机的权值，整个树按照这个打乱</span><br>    <span class="hljs-comment">//当然，rd也可以被称为该节点的优先级</span><br>&#125;trp[<span class="hljs-number">1500000</span>];<br><span class="hljs-type">int</span> tot,root;<br><span class="hljs-type">int</span> seed=<span class="hljs-number">5201314</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rrand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> seed=(<span class="hljs-type">int</span>)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(seed)*<span class="hljs-number">974485642LL</span>%<span class="hljs-number">21474836LL</span>);<br>    <span class="hljs-comment">/*手写rand()取随机数*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">newnode</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;now,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    val = val</span><br><span class="hljs-comment">    size = 1</span><br><span class="hljs-comment">    cnt = 1;</span><br><span class="hljs-comment">    rd rand()</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*基础的新建节点，没毛病*/</span><br>    now = ++tot;<br>    trp[now].val = val;<br>    trp[now].size = trp[now].cnt = <span class="hljs-number">1</span>;<br>    trp[now].rd = <span class="hljs-built_in">rrand</span>();<br>    <span class="hljs-comment">/*这里吐槽下,treap真的是看脸的算法啊*/</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    <span class="hljs-comment">/*更新新节点，很简单，这里没啥问题 */</span><br>    trp[now].size = trp[trp[now].son[<span class="hljs-number">0</span>]].size+trp[trp[now].son[<span class="hljs-number">1</span>]].size+trp[now].cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;now,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    自闭了十分钟的旋转操作，</span><br><span class="hljs-comment">    位运算理解成左右儿子切换或者左右方向切换就好。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">int</span> son = trp[now].son[d^<span class="hljs-number">1</span>];<br>    trp[now].son[d^<span class="hljs-number">1</span>] = trp[son].son[d];<br>    trp[son].son[d] = now;<br>    now = son;<br>    <span class="hljs-comment">/*注意，从下到上更新，先更新旋转后节点的d儿子，最后更新旋转的now节点*/</span><br>    <span class="hljs-built_in">update</span>(trp[now].son[d]);<br>    <span class="hljs-built_in">update</span>(now);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;now,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!now)&#123;<br>        <span class="hljs-built_in">newnode</span>(now,val);<span class="hljs-comment">//终于可以插入新节点了</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-comment">//在那之前，我们需要找到在何处插</span><br>    ++trp[now].size;<br>    <span class="hljs-keyword">if</span>(trp[now].val==val)&#123;<br>        trp[now].cnt++;<span class="hljs-comment">//前面提到的计数器，相同的值直接统计数量就好</span><br>        <span class="hljs-built_in">update</span>(now);<span class="hljs-comment">//我还在思考这里要不要update一下</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(trp[now].val&gt;val)&#123;<br>        <span class="hljs-built_in">insert</span>(trp[now].son[<span class="hljs-number">0</span>],val);<br>        <span class="hljs-keyword">if</span>(trp[now].rd&lt;trp[trp[now].son[<span class="hljs-number">0</span>]].rd)<br>            <span class="hljs-built_in">rotate</span>(now,<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-comment">//左右分头，记住一点，这棵树中，越往上rd越大，所以我们if比较里的内容其实很简单</span><br>    <span class="hljs-comment">//如果遇到儿子的rd比父辈大的时候，我们就旋转一下</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">insert</span>(trp[now].son[<span class="hljs-number">1</span>],val);<br>        <span class="hljs-keyword">if</span>(trp[now].rd&lt;trp[trp[now].son[<span class="hljs-number">1</span>]].rd)<br>            <span class="hljs-built_in">rotate</span>(now,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">update</span>(now);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;now,<span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!now)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//都没节点了，你删个锤子，可以加返回值判断是否删成功</span><br>    ++trp[now].size;<br>    <span class="hljs-keyword">if</span>(trp[now].val==val)&#123;<br>        <span class="hljs-keyword">if</span>(trp[now].cnt&gt;<span class="hljs-number">1</span>)&#123;<br>            trp[now].cnt--;<br>            <span class="hljs-built_in">update</span>(now);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(trp[now].son[<span class="hljs-number">0</span>]||trp[now].son[<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">if</span>(!trp[now].son[<span class="hljs-number">1</span>]||trp[trp[now].son[<span class="hljs-number">0</span>]].rd&gt;trp[trp[now].son[<span class="hljs-number">1</span>]].rd)<br>                <span class="hljs-built_in">rotate</span>(now,<span class="hljs-number">1</span>),<span class="hljs-built_in">del</span>(trp[now].son[<span class="hljs-number">1</span>],val);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">rotate</span>(now,<span class="hljs-number">0</span>),<span class="hljs-built_in">del</span>(trp[now].son[<span class="hljs-number">0</span>],val);<br>        &#125;<span class="hljs-comment">//删除这段其实用手画三四张模拟就懂了</span><br>        <span class="hljs-keyword">else</span> now = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-comment">//蒟蒻的我可能会在B站录个视频什么的</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trp[now].val&gt;val)<br>        <span class="hljs-built_in">del</span>(trp[now].son[<span class="hljs-number">0</span>],val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">del</span>(trp[now].son[<span class="hljs-number">1</span>],val);<br>    <span class="hljs-built_in">update</span>(now);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> val)</span></span>&#123; <span class="hljs-comment">//找到val的排名</span><br>    <span class="hljs-keyword">if</span>(!now)<br>        <span class="hljs-keyword">return</span> INT_MIN;<br>    <span class="hljs-keyword">if</span>(trp[now].val==val)<br>        <span class="hljs-keyword">return</span> trp[trp[now].son[<span class="hljs-number">0</span>]].size+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trp[now].val&gt;val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_rank</span>(trp[now].son[<span class="hljs-number">0</span>],val);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> trp[trp[now].son[<span class="hljs-number">0</span>]].size + trp[now].cnt + <span class="hljs-built_in">find_rank</span>(trp[now].son[<span class="hljs-number">1</span>],val);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_val</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> rank)</span></span>&#123; <span class="hljs-comment">//找到排名为rank的值</span><br>    <span class="hljs-keyword">if</span>(!now)<br>        <span class="hljs-keyword">return</span> INT_MAX;<br>    <span class="hljs-keyword">if</span>(trp[trp[now].son[<span class="hljs-number">0</span>]].size&gt;=rank)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_val</span>(trp[now].son[<span class="hljs-number">0</span>],rank);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trp[trp[now].son[<span class="hljs-number">0</span>]].size+trp[now].cnt&gt;=rank)<br>        <span class="hljs-keyword">return</span> trp[now].val;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_val</span>(trp[now].son[<span class="hljs-number">1</span>],rank-trp[trp[now].son[<span class="hljs-number">0</span>]].size-trp[now].cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123; <span class="hljs-comment">//找到val的前驱</span><br>    re <span class="hljs-type">int</span> now = root,pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(now)&#123;<br>        <span class="hljs-keyword">if</span>(trp[now].val&lt;val)<br>            pre = trp[now].val,now = trp[now].son[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span><br>            now = trp[now].son[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_nex</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;  <span class="hljs-comment">//找到val的后继</span><br>    re <span class="hljs-type">int</span> now = root,nex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(now)&#123;<br>        <span class="hljs-keyword">if</span>(trp[now].val&gt;val)<br>            nex = trp[now].val,now = trp[now].son[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span><br>            now = trp[now].son[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nex;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//读入优化</span><br>    re <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    re <span class="hljs-type">bool</span> f = <span class="hljs-number">1</span>;<br>    re <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)ch==<span class="hljs-string">&#x27;-&#x27;</span>?f=<span class="hljs-number">0</span>,ch=<span class="hljs-built_in">getchar</span>():ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)ans =(ans&lt;&lt;<span class="hljs-number">3</span>)+(ans&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>),ch = <span class="hljs-built_in">getchar</span>(); <br>    <span class="hljs-keyword">return</span> f?ans:-ans;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,last = <span class="hljs-number">0</span>,ans = <span class="hljs-number">0</span>,ooo;<br>    n = <span class="hljs-built_in">read</span>();m = <span class="hljs-built_in">read</span>();++n;++m;<br>    <span class="hljs-keyword">while</span>(--n)&#123;<br>        ooo = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">insert</span>(root,ooo);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(--m)&#123;<br>        <span class="hljs-type">int</span> opt,x;<br>        opt = <span class="hljs-built_in">read</span>();<br>        x = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">switch</span>(opt)&#123; <span class="hljs-comment">//这里就是一个简单的switch语句，我就不多说了</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">insert</span>(root,x^last);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">del</span>(root,x^last);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                ans ^= (last = <span class="hljs-built_in">find_rank</span>(root,x^last));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                ans ^= (last = <span class="hljs-built_in">find_val</span>(root,x^last));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                ans ^= (last = <span class="hljs-built_in">find_pre</span>(x^last));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                ans ^= (last = <span class="hljs-built_in">find_nex</span>(x^last));<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>感谢观看，如有不懂欢迎评论，博主全年365天无休，24小时内必回</p>
<p>嘿嘿，点个关注推荐呗 ~</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Treap</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>【深度学习】检测CUDA、cuDNN、Pytorch是否可用</title>
    <url>/2023/01/4de6703a/</url>
    <content><![CDATA[<h1
id="检测cudacudnnpytorch是否可用">检测CUDA、cuDNN、Pytorch是否可用</h1>
<p>大家看完代码不妨看一下后文的详解哦~</p>
<p>默子在原有基础上增加了很多新的内容。</p>
<p><strong>解释的更加详细，更加具体，更加新颖！</strong></p>
<p>废话不多说，我们直接开始。</p>
<hr />
<p>复制下列代码到IDE中运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;CUDA版本:&#x27;</span>,torch.version.cuda)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Pytorch版本:&#x27;</span>,torch.__version__)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;显卡是否可用:&#x27;</span>,<span class="hljs-string">&#x27;可用&#x27;</span> <span class="hljs-keyword">if</span>(torch.cuda.is_available()) <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不可用&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;显卡数量:&#x27;</span>,torch.cuda.device_count())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;是否支持BF16数字格式:&#x27;</span>,<span class="hljs-string">&#x27;支持&#x27;</span> <span class="hljs-keyword">if</span> (torch.cuda.is_bf16_supported()) <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不支持&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前显卡型号:&#x27;</span>,torch.cuda.get_device_name())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前显卡的CUDA算力:&#x27;</span>,torch.cuda.get_device_capability())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前显卡的总显存:&#x27;</span>,torch.cuda.get_device_properties(<span class="hljs-number">0</span>).total_memory/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>,<span class="hljs-string">&#x27;GB&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;是否支持TensorCore:&#x27;</span>,<span class="hljs-string">&#x27;支持&#x27;</span> <span class="hljs-keyword">if</span> (torch.cuda.get_device_properties(<span class="hljs-number">0</span>).major &gt;= <span class="hljs-number">7</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不支持&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前显卡的显存使用率:&#x27;</span>,torch.cuda.memory_allocated(<span class="hljs-number">0</span>)/torch.cuda.get_device_properties(<span class="hljs-number">0</span>).total_memory*<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;%&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>如果可以正常使用，大概率是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs 输出结果">CUDA版本: 11.7<br>Pytorch版本: 1.13.1+cu117<br>显卡是否可用: 可用<br>显卡数量: 1<br>是否支持BF16数字格式: 不支持<br>当前显卡型号: NVIDIA GeForce GTX 960M<br>当前显卡的CUDA算力: (5, 0)<br>当前显卡的总显存: 3.9998779296875 GB<br>是否支持TensorCore: 不支持<br>当前显卡的显存使用率: 0.0 %<br></code></pre></td></tr></table></figure>
<hr />
<p>代码逐行剖析：</p>
<ol type="1">
<li><p><code>torch.version.cuda</code></p>
<p>会输出当前CUDA的版本，一般来说，会有 <strong>11.7</strong> 和
<strong>11.3</strong>
（更老的版本可能会出现兼容性问题，建议大家去更新一下，直接到
<code>Nvidia</code> 官网就可以）</p></li>
</ol>
<hr />
<ol start="2" type="1">
<li><p><code>torch.__version__</code> .</p>
<p>会输出当前 Pytorch 的版本， 对于<code>1.13.1+cu117</code></p></li>
</ol>
<ul>
<li><p><code>1.13.0</code> 表示当前Pytorch的大版本，目前主流的版本大约在
<code>1.8.0</code> -
<code>1.13.0</code>，当大家开始复现代码时，就会发现自己要在电脑上同时装好多个Pytorch版本，所以用
<code>Conda</code>
去管理虚拟环境是很有必要的一件事哦~，大家对<code>Conda虚拟环境管理</code>
感兴趣的话，不妨点个赞，默子看看下期要不要出。</p></li>
<li><p><code>cu113</code> 表示当前 Pytorch
是GPU的，CUDA版本是11.3，如果是 <code>cp39</code> 表示当前 Pytorch
是CPU版本，Python版本是3.9.X</p></li>
<li><p>有的同学会看到<code>dev</code>开头的一串序号，<code>dev20230114</code>
表示是开发构建版（Pytorch.Nightly），具体构建日期为2023年1月14日，没有的话则是稳定版（Pytorch.Stable）。</p></li>
</ul>
<hr />
<ol start="3" type="1">
<li><p><code>torch.cuda.is_available()</code></p>
<p>返回GPU是否可用，可用为<code>True</code>，不可用为
<code>False</code></p></li>
</ol>
<hr />
<ol start="4" type="1">
<li><p><code>torch.cuda.device_count()</code></p>
<p>返回显卡数量，大家的电脑一般都是 <code>1</code>
啦，哈哈哈（友情提示：如果电脑是多GPU的，上述代码只能列出第一个GPU设备的部分信息，并不能列出全部GPU的信息。如果想获取全部信息，可以先获取GPU列表，然后循环输出每个GPU）</p></li>
</ol>
<hr />
<ol start="5" type="1">
<li><p><code>torch.cuda.is_bf16_supported()</code></p>
<p>显卡是否支持BF16计算，支持为<code>True</code>，不支持为
<code>False</code> &gt; BF16，有时也被称为BFloat16或Brain
Float16，是一种针对人工智能与深度学习应用程序进行优化的新数字格式。
它在谷歌、 英特尔 、 Arm
和许多其他公司的人工智能加速器得到了广泛的应用。使用BF16主要是因为，神经网络对指数的大小比尾数敏感得多，所以不必使用传统尾数精度更高的FP64或者是FP32。
默子的960M是肯定不支持BF16的，目前支持BF16的显卡有很多，比较大众化的应该就是NVIDIA
<a
href="https://baike.baidu.com/item/%E9%BB%84%E4%BB%81%E5%8B%8B/6343558">老黄</a>家<sup>NVIDIA创始人兼首席执行官</sup>的
RTX3060 和 RTX3070
了。至于专业的深度学习卡，绝大部分都是支持的。</p></li>
</ol>
<hr />
<ol start="6" type="1">
<li><p><code>torch.cuda.get_device_capability()</code></p>
<p>获取GPU的算力 <strong>（CUDA Capability Major/Minor version
number）</strong> ，对于N卡来说，查看全部型号显卡的算力请访问 <a
href="https://developer.nvidia.com/cuda-gpus#compute">https://developer.nvidia.com/cuda-gpus#compute</a>
（其余显卡请读者自行搜索吧） &gt;
在官方给出的文档中，如果进行神经网络的训练，建议GPU此数值在 5.0
以上（默子的卡刚刚及格，呜呜呜）</p></li>
</ol>
<hr />
<ol start="7" type="1">
<li><code>torch.cuda.get_device_properties(0).total_memory</code></li>
</ol>
<p>该条命令可以获取到当前GPU的总显存大小。详细信息可参考Pytorch官方文档<a
href="https://pytorch.org/docs/stable/generated/torch.cuda.get_device_properties.html">https://pytorch.org/docs/stable/generated/torch.cuda.get_device_properties.html</a></p>
<hr />
<ol start="8" type="1">
<li><code>TensorCore</code> 能力</li>
</ol>
<p>传统的N卡GPU都会有<code>CUDA</code>核心，用来处理大量的浮点运算。而
<code>Tensor</code>核心能加速处于深度学习神经网络训练和推理运算核心的矩阵计算，能够在维持超低精度损失的同时大幅加速推理吞吐效率。不过，最近几年的卡才会搭载<code>TensorCore</code>，这个会直接体现在显卡的算力等级上，大于<code>7</code>的显卡才会有搭载
<code>TensorCore</code>。</p>
<blockquote>
<p>具体是如何加速的，以及具体会加速多少，这个涉及到CUDA和Tensor核心的底层原理与深度学习相关知识。默子就不在这里展开阐述了，感兴趣的同学可以找一些文章、视频去看看。但就一句话，在深度学习方面，<code>TensorCore</code>吊打
<code>CUDACore</code>。</p>
</blockquote>
<hr />
<h4 id="section">$$</h4>
]]></content>
  </entry>
  <entry>
    <title>【杂记】2020年3月9日</title>
    <url>/2020/03/50796d93/</url>
    <content><![CDATA[<p>又是很颓的一天啊……</p>
<p>日常肝题，奇怪的是今天居然没有玩游戏</p>
<h2 id="上午1030">上午10:30</h2>
<p>其实醒来有很长时间了</p>
<p>但是一直懒在床上没有动，看了会
<strong>许胤龙的《组合数学引论》</strong></p>
<p><del>怎么可能看懂，这个东西简直需要两个脑子</del></p>
<p>对<strong>Fibonacci数</strong>和<strong>Catalan数</strong>有了更深刻的认识。</p>
<p>但是还有些不太明白，明天再看看书吧……</p>
<p>唉，当一个蒟蒻的快乐是大佬们永远体验不到的</p>
<p>新知识的海洋在向蒟蒻招手。</p>
<p>至于大佬呢？大佬们忙着发现新的类地星球，不屑于在地表游玩。</p>
<h3
id="安利一款超棒的游戏坎巴拉的太空计划">安利一款超棒的游戏《坎巴拉的太空计划》</h3>
<blockquote>
<p>虽然我还不怎么会玩，勉强靠着新手教程发射了第一次火箭</p>
</blockquote>
<blockquote>
<p>但是游戏真的超棒，物理、航天、宇宙爱好者的最佳选择</p>
</blockquote>
<blockquote>
<p>这里贴一段游戏评论</p>
</blockquote>
<p><strong>本游戏百小时都出不了新手村</strong></p>
<p>但是作为一个太空模拟它做到了尽可能的真实（相比其他游戏</p>
<p>没有什么超光速引擎，没有跃迁，没有虫洞</p>
<p>你用最笨拙的方式——燃料和引力飞向星空</p>
<p>在其他游戏里习惯了线性一样的移动后，回过头来看看这个游戏</p>
<p>它真正代表了人类对太空在历史上的探索</p>
<figure>
<img src="https://s2.ax1x.com/2020/03/09/89xvXn.jpg"
alt="坎巴拉的太空计划-游戏截图" />
<figcaption aria-hidden="true">坎巴拉的太空计划-游戏截图</figcaption>
</figure>
<p>听说最近出系列2了，如果有机会的话，夏天入手，<strong>112RMB</strong></p>
<p>学生党伤不起啊……</p>
<hr />
<h2 id="中午1230">中午12：30</h2>
<p>麻婆豆腐香啊，三碗米饭????是日常操作。</p>
<p>写到这里，我觉得我该减肥了????????????</p>
<p>嗯，从明天开始做一些运动吧……</p>
<p>不过，现在吃饱了才有力气明天减肥嘛<code>负罪感--</code></p>
<h2 id="下午1800">下午18：00</h2>
<p>午觉愣是睡成了下午觉！！！</p>
<p>打开手机，本想着逛一会B站，但是看了看日历</p>
<p>今天距离<strong>省选</strong>还有——<strong>20</strong>天啊。</p>
<p>算了，学习吧。</p>
<p><strong>熟悉的洛谷，熟悉的味道</strong></p>
<h3 id="st表的原理以及实现">ST表的原理以及实现</h3>
<p>今天搞了一下快忘掉的一些数据结构和算法</p>
<p>众所周知，在维护区间最值的时候，我们常用两种算法，一种叫ST表，一种叫线段树</p>
<p>这里主要说下<strong>ST表(Sparse Table)</strong></p>
<p><strong>预处理时间复杂度<code>O(nlogn)</code></strong></p>
<p><strong>查询时间复杂度<code>O(1)</code></strong></p>
<p>我们首先定义一个初始数据数组和二维的ST表数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//n为数据大小</span><br><span class="hljs-type">int</span> a[n]    存初始数据<br><span class="hljs-comment">//21后面具体再解释,其实当你看完原理也就懂了</span><br><span class="hljs-type">int</span> st[n][<span class="hljs-number">21</span>]    存ST表<br></code></pre></td></tr></table></figure>
<p><span class="math inline">\(st[ i ][ j ]表示的是区间[ i , i+2^j-1
]里的最大值\)</span></p>
<p><span class="math inline">\(所以，st[ i ][ j ] = max(st[ i ][ j-1 ] ,
st[ i+2^(j-1) ][ j-1 ])\)</span></p>
<p><span
class="math inline">\(这里以维护区间最大值来举例，最大值最小值其实都一样，只有\)</span><strong>max</strong><span
class="math inline">\(和\)</span><strong>min</strong><span
class="math inline">\(的区别\)</span></p>
<h3 id="初始化st表">初始化ST表</h3>
<p>怎么来的呢？</p>
<p>个人觉得，简单来说就是一个 <code>二分+分治</code> 的思想</p>
<p><strong>我们要求区间 <span class="math inline">\([ i , i+2^j-1
]\)</span> 里的最大值</strong></p>
<p><strong>可以先求区间 <span class="math inline">\([ i , i+2^(j-1)-1
]\)</span> 里的最大值</strong></p>
<p><strong>再求区间 <span class="math inline">\([ i+2^(j-1) , i+2^j-1
]\)</span> 里的最大值</strong></p>
<p><strong>最后取这两个区间的最大值</strong></p>
<p>所以，<span class="math inline">\(st[ i ][ j ] = max(st[ i ][ j-1 ] ,
st[ i+2^(j-1) ][ j-1 ])\)</span></p>
<p>如果还是不理解的话，再看一下st数组的含义</p>
<p><span class="math inline">\(st[ i ][ j ]\)</span>表示的是区间<span
class="math inline">\([ i , i+2^j-1 ]\)</span>里的最大值</p>
<p>初始化最小单元，也就是 <span class="math inline">\(st[ i ][ 0
]\)</span> ，也就是区间 <span class="math inline">\([ i , i ]\)</span>
里的最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    st[i][<span class="hljs-number">0</span>]=a[i];<br></code></pre></td></tr></table></figure>
<p>初始化剩余部分，这里用到了位运算节约时间开销</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;j++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;i++)<br>        st[i][j] = <span class="hljs-built_in">max</span>(st[i][j<span class="hljs-number">-1</span>],st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure>
<h3 id="查询st表">查询ST表</h3>
<p>ST表的查询许多萌新上来会迷惑的一个操作</p>
<p>比如，我们要查询区间 <span class="math inline">\([ l , r ]\)</span>
里的最大值</p>
<p>如果这个区间恰好是<strong>ST表</strong>里的一个区间 <span
class="math inline">\([ i , i+2^j-1 ]\)</span> ，那么我们就可以直接访问
<span class="math inline">\(st[i][j]\)</span></p>
<p>可惜大多时候都不是，那么我们怎么做呢？我们可以这样做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(r-l+<span class="hljs-number">1</span>)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">max</span>(st[l][k],st[y-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure>
<p>这里的 <span class="math inline">\(y\)</span> 是什么呢？ <span
class="math inline">\(y\)</span> 是满足 <span
class="math inline">\(y-(1&lt;&lt;k)+1&lt;=r\)</span> 的最大值</p>
<p><span class="math inline">\(k\)</span>是什么呢？<span
class="math inline">\(k\)</span> 是满足 <span
class="math inline">\(2^k&lt;=r-l+1\)</span> 的最大值</p>
<p>最后比较的两个区间 <span class="math inline">\([l,l+2^k]\)</span> 和
<span class="math inline">\([r-2^k,r]\)</span>
有可能是重合的，但是答案是唯一的</p>
<p><del><strong>板子还是要自己打，不然怎么才能背会呢？</strong></del></p>
<h2 id="晚上2230">晚上22：30</h2>
<p>刷题的日子总是这么朴实无华且枯燥</p>
<p>写完博客，一看表居然已经12点了</p>
<p>看来我还是太菜，一篇杂记类博客居然要写一个半小时。</p>
<p>今天AK洛谷第一页黄题，明天继续肝吧，绿题蓝题要提上日程了</p>
<p>之前有位大佬建议我刷满2页蓝，……太犇了。</p>
<p>继续加油吧，不忘初心。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>日常</tag>
        <tag>洛谷</tag>
        <tag>ST表</tag>
        <tag>坎巴拉的太空计划</tag>
        <tag>Fibonacci数</tag>
        <tag>Catalan数</tag>
      </tags>
  </entry>
  <entry>
    <title>【计科漫谈】都2023了，你还不会使用Markdown？</title>
    <url>/2023/05/1d0b3c6c/</url>
    <content><![CDATA[<p>【计科漫谈】<strong>都2023了，你还不会使用Markdown？</strong></p>
<p>虽然这个标题有些攻击性，但相信默子，绝对不是有意的。</p>
<p>2023的第二周马上要过去了，大年三十也已经在来的路上了。在这闲暇但也不太闲暇的日子里，学点Markdown为2023助助力吧！</p>
<p><strong>相信它会成为你新一年学习工作的好助手哒！</strong></p>
<hr />
<h2 id="markdown-是什么">Markdown 是什么</h2>
<p>Wikipedia 词条 <a
href="https://en.wikipedia.org/wiki/Markdown">Markdown</a></p>
<p>Markdown
是一种轻量级的标记语言，可用于在<strong>纯文本文档</strong>中添加<strong>格式化元素</strong>。Markdown
由 John Gruber 于 2004
年创建，如今已成为世界上<strong>最受欢迎</strong>的标记语言之一。</p>
<p>默子个人觉得，Markdown是一种 ==学习成本超低==
，但是带来的<strong>回报率超高</strong>的一种标记语言。可以只用一些简单的符号，做到格式化文本，排版文章，做表插图。</p>
<hr />
<h2 id="markdown-用在何处">Markdown 用在何处</h2>
<ol type="1">
<li>==用来写技术博客==，记录学习笔记，常见的写作平台有CSDN、Github、掘金等。还可以在期末时直接将笔记作为报告。</li>
<li>Obsidian知识管理，知识的输入与输出，构建数字大脑（使用的语法是Markdown）</li>
</ol>
<blockquote>
<p>一般来说，Markdown
在非程序员的圈子里知名度其实不高，而且即使很多程序员菜鸟，也要一两年才会接触到
Markdown</p>
<p>但是Markdown的优点真的是数不胜数，默子可以列举很多</p>
</blockquote>
<hr />
<h2 id="markdown的优点">Markdown的优点</h2>
<ul>
<li>==绝对的跨平台==，因为
Markdown的文件本身就是一个文本文件，<code>.md</code>
可以用任意的文本编辑器打开，不存在兼容性的问题。最多是不同Markdown的渲染器渲染出来的效果不一样罢了。</li>
<li>==格式设置简洁优美==，在传统排版软件Word中需要很多操作才可以完成的内容，在Markdown中就是多敲几个字符的事情。</li>
<li>==让写作者更专注于内容的输出==，不会被复杂的排版，恼人的乱码困扰，记住十几个特定的字符，比在Word里面频繁的操作要省事的多。（其实就是追求的一种极简主义，简化不重要的边角，强化内容的核心）</li>
<li>支持 <span class="math inline">\(\LaTeX\)</span>
数学公式，让数学公式编辑不再折磨。</li>
</ul>
<hr />
<h2 id="markdown-基础语法">Markdown 基础语法</h2>
<p>Markdown里的基本语法不多，这里将介绍最主要的语法。更多扩展语法，默子会放出官方全面的网站，供大家收藏，日后方便查阅。</p>
<blockquote>
<p>标题、加粗、斜体、粗斜体、高亮、删除线、下划线、引用、链接、图片插入</p>
</blockquote>
<h4
id="标题用-表示标题一级标题一个-二级标题两个-最高有六级标题">标题：用
<code>#</code> 表示标题，一级标题一个 <code>#</code> ，二级标题两个
<code>#</code> ，最高有六级标题。</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1级标题</span><br><span class="hljs-section">## 2级标题</span><br><span class="hljs-section">### 3级标题</span><br><span class="hljs-section">#### 4级标题</span><br><span class="hljs-section">##### 5级标题</span><br><span class="hljs-section">###### 6级标题</span><br></code></pre></td></tr></table></figure>
<h4 id="加粗用-内容-包裹起来字体加粗">加粗：用 <code>**内容**</code>
包裹起来，字体加粗</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**加粗的内容**</span><br></code></pre></td></tr></table></figure>
<p><strong>加粗的内容</strong></p>
<h4 id="斜体用-内容-包裹起来字体倾斜">斜体：用 <code>*内容*</code>
包裹起来，字体倾斜</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体的内容*</span><br></code></pre></td></tr></table></figure>
<p><em>斜体的内容</em></p>
<h4 id="粗斜体用-内容-包裹起来字体加粗倾斜">粗斜体：用
<code>***内容***</code> 包裹起来，字体加粗倾斜</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体的内容*</span>**</span><br></code></pre></td></tr></table></figure>
<p><strong><em>粗斜体的内容</em></strong></p>
<h4 id="高亮用-内容-包裹起来字体背景高亮">高亮：用 <code>==内容==</code>
包裹起来，字体背景高亮</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">==高亮的内容==<br></code></pre></td></tr></table></figure>
<p>==高亮的内容==</p>
<h4 id="下划线用-u内容u-包裹起来添加下划线">下划线：用
<code>&lt;u&gt;内容&lt;/u&gt;</code> 包裹起来，添加下划线</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>下划线的内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<p><u>下划线的内容</u></p>
<h4 id="删除线用-内容-包裹起来添加删除线">删除线：用
<code>~~内容~~</code> 包裹起来，添加删除线</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">~~删除线的内容~~<br></code></pre></td></tr></table></figure>
<p><del>删除线的内容</del></p>
<h4 id="引用每一行的开始使用-表示引用">引用：每一行的开始使用
<code>&gt;</code> 表示引用</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 我爱你，以身，以心，以血，以命！以沉默，以眼泪！以唯一，以终结！以漂泊的灵魂，以永恒的死亡！</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>我爱你，以身，以心，以血，以命！以沉默，以眼泪！以唯一，以终结！以漂泊的灵魂，以永恒的死亡！</p>
</blockquote>
<p>多层嵌套引用可以用 <code>&gt;&gt;</code> 来表示</p>
<blockquote>
<p>外层引用</p>
<blockquote>
<p>内层引用1</p>
</blockquote>
<p>可以引用多行</p>
<blockquote>
<p>内层引用2</p>
</blockquote>
</blockquote>
<h4
id="链接用链接名称链接地址来表示一个链接">链接：用<code>[链接名称](链接地址)</code>来表示一个链接</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">链接名称</span>](<span class="hljs-link">链接地址</span>)<br>[<span class="hljs-string">Markdown - Wikipedia</span>](<span class="hljs-link">https://en.wikipedia.org/wiki/Markdown</span>)<br></code></pre></td></tr></table></figure>
<p><a href="链接地址">链接名称</a></p>
<p><a href="https://en.wikipedia.org/wiki/Markdown">Markdown -
Wikipedia</a></p>
<h4
id="图片插入用图片描述图片地址来在文章中插入图片">图片插入：用<code>![图片描述](图片地址)</code>来在文章中插入图片</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">https://profile.csdnimg.cn/3/5/3/1_qq_35657309</span>)<br></code></pre></td></tr></table></figure>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/bfd1b8a6278d4576e183dbea48401416.png" /></p>
<p>以上就是Markdown最基础的语法啦！相信大家应该都已经学会了叭。</p>
<p>默子一直是秉持着，<code>先用起来，再不断巩固拓展。</code></p>
<p>所以，其实上面的Markdown语法已经足够大家日常使用了。</p>
<p>如果有更多的需求，不妨看看默子下方推荐的学习资料哦！</p>
<hr />
<h2 id="markdown-参考学习资料">Markdown 参考学习资料</h2>
<ol type="1">
<li><a href="https://www.markdownguide.org/getting-started/">Getting
Started | Markdown Guide</a></li>
</ol>
<blockquote>
<p>Markdown Guide
官方的英文教程，大家英文水平如果OK的话，不妨去看一下（可能国内访问会比较困难）</p>
</blockquote>
<ol start="2" type="1">
<li><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown
教程 | 菜鸟教程 (runoob.com)</a></li>
</ol>
<blockquote>
<p>菜鸟的中文教程，讲的十分详细清晰，建议小伙伴们看这个，同时有
[[VSCode]] 的详细操作教程，对于零基础小伙伴来说十分友好。</p>
</blockquote>
<ol start="3" type="1">
<li><a
href="https://markdown.com.cn/intro.html#markdown-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">Markdown
入门基础 | Markdown 官方教程</a></li>
</ol>
<blockquote>
<p>官方中文教程，十分详细，但是可能其中的内容并不适合所有的初学者了解，
比如 <a
href="https://markdown.com.cn/intro.html#markdown-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F">Markdown
的工作原理</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>【博客】一些想说的话</title>
    <url>/2023/05/81817ba7/</url>
    <content><![CDATA[<h2 id="一些关于博客想说的话">一些关于博客想说的话</h2>
<h3 id="为什么要写博客">1. 为什么要写博客</h3>
<p>默子其实也不知道，只是觉得学到一些技术，用博客记录下来，也算是对自己的一种总结吧。</p>
<p>同时还可以帮到更多的人，何乐而不为呢？</p>
<h3 id="为什么要用hexo">2. 为什么要用Hexo</h3>
<p>折腾了这么久，发现还是这种静态博客框架比较简单方便，其他的框架玩着玩着就搞起了前后端训练，很难绷。</p>
<p><code>Github+Hexo+Next</code>
，简直就是懒人一键建站最佳方案（当然，你得有一点点基础）。</p>
<p>关于之前折腾的框架，少说也有七八个了，常见的主流的，都玩过</p>
<p>这个博客从想法到部署，也就是30分钟的事情。（可能是已经折腾出了技术吧，哈哈哈哈，总之就是一个熟练工）</p>
<h3 id="为什么要用github">3. 为什么要用Github</h3>
<p>虽然国内访问Github
Pages速度不是很快，但没关系。默子预估能看到这篇文章的人，大概率都已经是技术力比较高的CS相关人士了。</p>
<p><strong>手里没几把趁手的梯子，说得过去嘛</strong></p>
<h3 id="之后的更新">4. 之后的更新</h3>
<p>这个纯纯随缘了，基本上想到什么就去更新什么。</p>
<p>在其他平台还有很多的文章，默子也会慢慢的迁移过来。（最好是整理之后，不然其他平台的文章现在太乱了）</p>
<p>有可能一天爆更10篇文章，也有可能两个星期没啥更新。毕竟，随缘博主是这样的，哈哈哈哈</p>
<h3 id="关于博客的一些想法">5. 关于博客的一些想法</h3>
<p>写博客，记录的自己，看的是别人。</p>
<p>所以，这里定一些小小的规矩，也是对自己的一种约束吧：</p>
<ol type="1">
<li>尽量少用ChatGPT来完成博客的写作</li>
<li>保持每个月至少有两篇文章更新，不能一断就断没影了</li>
<li>技术类的文章质量做到 <code>Top 10%</code> ，不能摸鱼划水</li>
<li>日常生活和点滴记录也可以发</li>
</ol>
<hr />
<h3 id="测试部分">7. 测试部分</h3>
<h1 id="h1标题">H1标题</h1>
<h2 id="h2标题">H2标题</h2>
<h3 id="h3标题">H3标题</h3>
<h4 id="h4标题">H4标题</h4>
<h5 id="h5标题">H5标题</h5>
<h6 id="h6标题">H6标题</h6>
<p><strong>加粗</strong></p>
<p><em>斜体</em></p>
<p><del>删除线</del></p>
<p><u>下划线</u></p>
<p>==高亮==</p>
<blockquote>
<p>引用：孔子曾经收过：学而时习之，不亦说乎？有朋自远方来，不亦乐乎？</p>
</blockquote>
<ul>
<li>无序列表</li>
<li>无序列表
<ul>
<li>二极管</li>
<li>三极管
<ul>
<li>NPN</li>
<li>PNP</li>
</ul></li>
</ul></li>
<li>无序列表</li>
</ul>
<ol type="1">
<li>有序列表
<ol type="1">
<li>什么是量子力学</li>
<li>什么是相对论</li>
<li>什么是广义相对论
<ol type="1">
<li>黑洞</li>
<li>白洞</li>
<li>虫洞</li>
</ol></li>
</ol></li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<ul class="task-list">
<li><input type="checkbox" />任务列表</li>
<li><input type="checkbox" />任务列表
<ul class="task-list">
<li><input type="checkbox" />任务列表</li>
<li><input type="checkbox" />任务列表</li>
</ul></li>
</ul>
<p><a href="/">链接</a></p>
<figure>
<img src="/img/bg1.webp" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//左偏树模版</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, fa[N], ch[N][<span class="hljs-number">2</span>], val[N], dis[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!x || !y) <span class="hljs-keyword">return</span> x | y;<br>    <span class="hljs-keyword">if</span> (val[x] &gt; val[y] || (val[x] == val[y] &amp;&amp; x &gt; y)) <span class="hljs-built_in">swap</span>(x, y);<br>    ch[x][<span class="hljs-number">1</span>] = <span class="hljs-built_in">merge</span>(ch[x][<span class="hljs-number">1</span>], y);<br>    fa[ch[x][<span class="hljs-number">1</span>]] = x;<br>    <span class="hljs-keyword">if</span> (dis[ch[x][<span class="hljs-number">0</span>]] &lt; dis[ch[x][<span class="hljs-number">1</span>]]) <span class="hljs-built_in">swap</span>(ch[x][<span class="hljs-number">0</span>], ch[x][<span class="hljs-number">1</span>]);<br>    dis[x] = dis[ch[x][<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val[i]), fa[i] = i;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> opt, x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;y);<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) fa[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-built_in">merge</span>(fx, fy);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i) != i) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, val[i]);<br>        <span class="hljs-type">int</span> x = ch[i][<span class="hljs-number">0</span>], y = ch[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (x) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, val[x]), x = ch[x][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span> (y) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, val[y]), y = ch[y][<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pytorch LSTM</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> torch.nn.utils.rnn <span class="hljs-keyword">import</span> pad_sequence<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, label</span>):<br>        self.data = data<br>        self.label = label<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">return</span> self.data[index], self.label[index]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.data)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSTM</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, num_layers, num_classes</span>):<br>        <span class="hljs-built_in">super</span>(LSTM, self).__init__()<br>        self.hidden_size = hidden_size<br>        self.num_layers = num_layers<br>        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=<span class="hljs-literal">True</span>)<br>        self.fc = nn.Linear(hidden_size, num_classes)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        h0 = torch.zeros(self.num_layers, x.size(<span class="hljs-number">0</span>), self.hidden_size).to(device)<br>        c0 = torch.zeros(self.num_layers, x.size(<span class="hljs-number">0</span>), self.hidden_size).to(device)<br>        out, _ = self.lstm(x, (h0, c0))<br>        out = self.fc(out[:, -<span class="hljs-number">1</span>, :])<br>        <span class="hljs-keyword">return</span> out<br><span class="hljs-comment"># 超参数</span><br>num_classes = <span class="hljs-number">2</span><br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">0.001</span><br>num_epochs = <span class="hljs-number">5</span><br><span class="hljs-comment"># 数据集</span><br>train_data = pd.read_csv(<span class="hljs-string">&#x27;train.csv&#x27;</span>)<br>test_data = pd.read_csv(<span class="hljs-string">&#x27;test.csv&#x27;</span>)<br>train_data = train_data.values<br>test_data = test_data.values<br><span class="hljs-comment"># 划分训练集和验证集</span><br>train_data = train_data[:<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(train_data) * <span class="hljs-number">0.8</span>)]<br><span class="hljs-comment"># 优化器</span><br>optimizer = optim.Adam(model.parameters(), lr=learning_rate)<br><span class="hljs-comment"># 损失函数</span><br>criterion = nn.CrossEntropyLoss()<br><span class="hljs-comment"># 训练</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># Device configuration</span><br>    device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br><br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现DOM的增删 改查</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>数学公式测试：</p>
<p><span
class="math display">\[\sum_{i=1}^{n}i=\frac{n(n+1)}{2}\]</span></p>
<p><span class="math display">\[ n \% m = 2^{n-1} \]</span></p>
<p><span class="math display">\[ \int_{a}^{b}f^{(3)}(t)dt \]</span></p>
<p><span
class="math display">\[\begin{pmatrix}ax+1&amp;1&amp;0\\1&amp;bx+2&amp;1\\0&amp;1&amp;cx+3\end{pmatrix}\]</span></p>
<p><span class="math display">\[ c =
(2^{7-n}-\frac{7e^{i\pi}}{6\pi})\frac{\pi}{n}+\mathrm{O}(n\lg{\lg{n}})\]</span></p>
<p><span class="math display">\[1 \leq a_i,b_i\leq max(n,m)\]</span></p>
<p><span
class="math display">\[\sum\limits_{i=1}^{n}(x_i-y_i)^n\]</span></p>
<p><span
class="math display">\[\prod\limits_{i=1}^{n(n-1)}(k_i+\frac{\sum\limits_{j-1}^{i}(x_i+y_i)^{\frac{3}{2}}}{e\ln{(i+1)}})-\epsilon\]</span></p>
<p><span class="math display">\[\dot{A_r} = \frac{\dot{x_0}}{\dot{x_i}}
= \frac{\dot{A}}{1+\dot{A}\dot{F}}\]</span></p>
<p><span class="math display">\[f(\theta) =
\frac{\sin{\theta}(\left|cos\right|)^{\frac{1}{2}}}{2\sin(\theta)+2}-2\sin{(\theta)}+2\]</span></p>
<p><span class="math display">\[\pi^{4}+\pi^{5}\approx
e^{6}\]</span></p>
<p><span
class="math display">\[\sqrt{1+2\sqrt{1+3\sqrt{1+4\sqrt{1+\dots}}}} =
3\]</span></p>
<p><span class="math display">\[\hat{f}(\xi) =
\frac{1}{(2\pi)^\frac{d}{2}}\int_{\mathbb{R}^d}e^{-ix\xi}f(x)dx\]</span></p>
<p><span
class="math display">\[\begin{bmatrix}1&amp;2&amp;3\\4&amp;5&amp;6\\7&amp;8&amp;9\end{bmatrix}\]</span></p>
<pre class="mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice->>John: Hello John, how are you?
    loop Healthcheck
        John->>John: Fight against hypochondria
    end
    Note right of John: Rational thoughts <br/>prevail!
    John-->>Alice: Great!
    John->>Bob: How about you?
    Bob-->>John: Jolly good!</pre>
<pre class="mermaid">gantt
dateFormat  YYYY-MM-DD
title 甘特时间轴
excludes weekdays 2014-01-10

section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d</pre>
<pre class="mermaid">classDiagram
title 类图
Class01 <|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --> C2 : Where am i?
Class09 --* C3
Class09 --|> Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 <--> C2: Cool label</pre>
<pre class="mermaid">journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me</pre>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
